소프트웨어 아키텍쳐

안티프레질

-오토스케일링

그룹에서 유지되어야 하는 최소한의 사이즈를 지정하고, 필요 시 늘리는 형식

CPU, DB 사용량에 따라 자동으로 처리


-마이크로서비스

넷플릭스 오오 b

클라우드 네이티브 아키텍쳐 - 개별적인 모듈들을 독립적으로 배포한다.


- 카오스 엔지니어링

시스템이 예측하지 못한 일이 생기더라도 안정적인 서비스를 제공해야 한다.

- CI/CD

배포 파이프라인
지속적인 통합, 배포

수십개~수만개의 도메인이 분리되어 개발된다.


---------------------------------------------------

[확장  가능한 아키텍처]

스케일업 - 하드웨어의 사양을 높인다.
스케일 아웃 - 같은 사양의 서버를 여러 대 둔다.

클라우드 서비스를 통해 효율적인 스케일아웃을 할 수 있게 됨

[탄력적 아키텍쳐]

분리된 서비스들간의 종속성을 최소화
무상태 통신 프로토콜

서비스의 위치를 등록해야 다른 서비스에서 사용을 할 수 있다. 


[장애 격리]

장애 복구에 뛰어나다
한 쪽에서 문제가 생겨도 다른 서비스에서는 오류 X


--------------------------------------------------

Cloud Native Application - 모르겟음...

마이크로서비스를 배포하기 위해서는 컨테이너를 사용한다. 

CI/CD 파이프라인 구축


데브옵스 - 개발, 검증, 운영의 서큘레이션을 지속적으로 한다. 


컨테이너 가상화 기술 - 공통 라이브러리 위에 독립적인 애플리케이션들을 운영한다. 적은 리소스 사용

가상머신 기술 - 호스트 운영체제에 많은 부하를 준다. 


---------------------------------------------

12 Factor

1. 코드를 한 곳에서 배포 -> 코드를 통일적으로 관리

2. 종속성

3. 코드 외부에서 환경설정을 제어

4. 서비스 지원
..

여러 서비스가 복제 되어 사용되기 때문에 동시성을 가지고 잇어야 한다. 

개발단계와 운영단계의 분리

프로세스 관리 (리포팅 및 데이터 분석 기능이 필요)

--------------------------------------------------

모놀리스 vs MSA

모놀리스 - 모든 업무 로직이 하나의 어플리케이션으로 서비스 됨

모놀리스와 MSA의 가장 큰 차이점 - 애플리케이션의 크기

어떤 언어를 쓸 것인지 어떤 DB를 사용할 것인지를 개별로 정해도 된다. - MSA의 특징


-------------------------------------------------
모놀리스와 MSA의 중간 방식 - 프론트와 백을 구분하는 개발 방식

MSA의 백엔드 단 - 독립적인 DB와 서비스를 사용하고 있음





